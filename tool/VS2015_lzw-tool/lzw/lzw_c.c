#ifdef __WINDOWS__
#include <Windows.h>
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "lzw_c.h"

#define my_inline

my_inline void _MEMSET_(void *_dst, int _val, size_t _sz)
{
	while (_sz) ((byte *)_dst)[--_sz] = _val;
}
my_inline void _MEMCPY_(void *_dst, void *_src, size_t _sz)
{
	while (_sz--) ((byte *)_dst)[_sz] = ((byte *)_src)[_sz];
}

my_inline void * mem_alloc(size_t item_size, size_t n_item)
{
#ifdef __WINDOWS__
	size_t * x = (size_t *)VirtualAlloc(NULL, sizeof(size_t) * 2 + n_item * item_size, MEM_COMMIT, PAGE_READWRITE);
	_MEMSET_(x, 0, sizeof(size_t) * 2 + n_item * item_size);
	x[0] = item_size;
	x[1] = n_item;
	return x + 2;
#else
	size_t *x = calloc(1, sizeof(size_t) * 2 + n_item * item_size);
	x[0] = item_size;
	x[1] = n_item;
	return x + 2;
#endif
}
my_inline void * mem_extend(void *m, size_t new_n)
{
	size_t * x = (size_t*)m - 2;
#ifdef __WINDOWS__
	size_t * tt = (size_t *)VirtualAlloc(x, sizeof(size_t) * 2 + *x * new_n, MEM_COMMIT, PAGE_READWRITE);
	if (tt == NULL)
	{
		tt = (size_t *)VirtualAlloc(NULL, sizeof(size_t) * 2 + *x * new_n, MEM_COMMIT, PAGE_READWRITE);
		if (tt == NULL)
			return NULL;
		else
		{
			_MEMCPY_(tt, x, new_n > x[1] ? sizeof(size_t) * 2 + *x * x[1] : sizeof(size_t) * 2 + x[0] * new_n);
			VirtualFree(x, 0, MEM_RELEASE);
			x = tt;
		}
	}
#else
	x = realloc(x, sizeof(size_t) * 2 + *x * new_n);
	if (new_n > x[1])
		memset((char*)(x + 2) + x[0] * x[1], 0, x[0] * (new_n - x[1]));
#endif
	x[1] = new_n;
	return x + 2;
}
my_inline void mem_zero(void *m)
{
	size_t * x = (size_t *)m - 2;
	_MEMSET_(m, 0, x[0] * x[1]);
}
my_inline void mem_release(size_t * x)
{
#ifdef __WINDOWS__
	VirtualFree((size_t *)x - 2, 0, MEM_RELEASE);
#else
	free((size_t*)(x)-2); x = 0;
#endif
}

#define _new(type, n) mem_alloc(sizeof(type), n)
#define _del(m)   mem_release((size_t *)m)
#define _len(m)   *((size_t*)m - 1)
#define _setsize(m, n)  m = mem_extend(m, n)
#define _extend(m)  m = mem_extend(m, _len(m) * 2)

#define M_CLR 256
#define M_EOD 257
#define M_NEW 258

typedef struct {
	ushort next[256];
} lzw_enc_t;
typedef struct {
	ushort prev, back;
	byte c;
} lzw_dec_t;

#define write_bits(x) do {                                         \
	tmp = (tmp << bits) | (ushort)x;         \
	o_bits += bits;                          \
	if (_len(out) <= out_len) _extend(out);  \
	while (o_bits >= 8) {                    \
		o_bits -= 8;                         \
		out[out_len++] = tmp >> o_bits;      \
		tmp &= (1 << o_bits) - 1;            \
	}                                        \
} while (0);
#define write_out(c) do {                      \
	while (out_len >= _len(out)) _extend(out); \
	out[out_len++] = (byte)c;                  \
} while (0);
#define get_code() do {               \
	while (n_bits < bits) {                \
		if (len > 0) {                     \
			len--;                         \
			tmp = (tmp << 8) | *(in++);    \
			n_bits += 8;                   \
		}                                  \
		else {                             \
			tmp = tmp << (bits - n_bits);  \
			n_bits = bits;                 \
		}                                  \
	}                                      \
	n_bits -= bits;                        \
	code = tmp >> n_bits;                  \
	tmp &= (1 << n_bits) - 1;              \
} while (0);
#define clear_table() do {                \
	mem_zero(d);                            \
	for (j = 0; j < 256; j++) d[j].c = j; \
	next_code = M_NEW;                    \
	next_shift = 512;                     \
	bits = 9;                             \
} while (0);

#ifdef _WINDOWS_
#ifndef _WIN64
// win_x86
byte shellcode[] = {
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x28, 0x53, 0x56, 0x57, 0x68, 0x33, 0x88, 0x5A, 0x9E, 0xE8, 0x7F,
	0x02, 0x00, 0x00, 0x8B, 0xD8, 0xC7, 0x04, 0x24, 0x92, 0xF1, 0xAE, 0x4F, 0x89, 0x5D, 0xEC, 0xE8,
	0x6E, 0x02, 0x00, 0x00, 0x59, 0x6A, 0x04, 0x68, 0x00, 0x10, 0x00, 0x00, 0x89, 0x45, 0xDC, 0xBE,
	0x08, 0x0C, 0x00, 0x00, 0x33, 0xC0, 0x56, 0x50, 0x89, 0x45, 0xF0, 0xFF, 0xD3, 0x33, 0xC9, 0x83,
	0xEE, 0x01, 0x88, 0x0C, 0x06, 0x75, 0xF8, 0x6A, 0x06, 0x5F, 0x8D, 0x50, 0x08, 0x89, 0x38, 0xC7,
	0x40, 0x04, 0x00, 0x02, 0x00, 0x00, 0x8B, 0xF1, 0x8B, 0xD9, 0x89, 0x55, 0xE8, 0x8B, 0xC1, 0x8D,
	0x4A, 0x04, 0x88, 0x01, 0x40, 0x03, 0xCF, 0x3D, 0x00, 0x01, 0x00, 0x00, 0x7C, 0xF4, 0x6A, 0x09,
	0x5F, 0xC7, 0x45, 0xF8, 0x02, 0x01, 0x00, 0x00, 0xC7, 0x45, 0xFC, 0x00, 0x02, 0x00, 0x00, 0x89,
	0x7D, 0xF4, 0x39, 0x5D, 0x0C, 0x0F, 0x84, 0xF0, 0x01, 0x00, 0x00, 0x3B, 0xF7, 0x7D, 0x2E, 0x8B,
	0x55, 0x0C, 0x85, 0xD2, 0x7E, 0x15, 0x8B, 0x4D, 0x08, 0x4A, 0xC1, 0xE3, 0x08, 0x0F, 0xB6, 0x01,
	0x0B, 0xD8, 0x41, 0x89, 0x4D, 0x08, 0x83, 0xC6, 0x08, 0xEB, 0x08, 0x8B, 0xCF, 0x2B, 0xCE, 0x8B,
	0xF7, 0xD3, 0xE3, 0x3B, 0xF7, 0x7C, 0xDB, 0x89, 0x55, 0x0C, 0x8B, 0x55, 0xE8, 0x2B, 0xF7, 0x8B,
	0xC3, 0x8B, 0xCE, 0x89, 0x75, 0xE0, 0xD3, 0xE8, 0x0F, 0xB7, 0xF0, 0x33, 0xC0, 0x40, 0xD3, 0xE0,
	0x48, 0x23, 0xD8, 0xB8, 0x01, 0x01, 0x00, 0x00, 0x89, 0x5D, 0xE4, 0x66, 0x3B, 0xF0, 0x0F, 0x84,
	0x97, 0x01, 0x00, 0x00, 0x48, 0x66, 0x3B, 0xF0, 0x75, 0x41, 0x8B, 0x42, 0xFC, 0x0F, 0xAF, 0x42,
	0xF8, 0x85, 0xC0, 0x74, 0x09, 0x83, 0xE8, 0x01, 0xC6, 0x04, 0x10, 0x00, 0x75, 0xF7, 0x33, 0xC0,
	0x8D, 0x4A, 0x04, 0xBE, 0x00, 0x01, 0x00, 0x00, 0x88, 0x01, 0x40, 0x8D, 0x49, 0x06, 0x3B, 0xC6,
	0x7C, 0xF6, 0x6A, 0x09, 0x5F, 0xC7, 0x45, 0xF8, 0x02, 0x01, 0x00, 0x00, 0xC7, 0x45, 0xFC, 0x00,
	0x02, 0x00, 0x00, 0x89, 0x7D, 0xF4, 0xE9, 0x3E, 0x01, 0x00, 0x00, 0x8B, 0x45, 0xF8, 0x66, 0x3B,
	0xF0, 0x0F, 0x83, 0x44, 0x01, 0x00, 0x00, 0x0F, 0xB7, 0xC0, 0xB9, 0xFF, 0x00, 0x00, 0x00, 0x6B,
	0xC0, 0x06, 0x8B, 0xDE, 0x89, 0x45, 0xD8, 0x66, 0x89, 0x34, 0x10, 0x66, 0x3B, 0xF1, 0x76, 0x23,
	0x8B, 0xF9, 0x0F, 0xB7, 0xC3, 0x6B, 0xC0, 0x06, 0x0F, 0xB7, 0x0C, 0x10, 0x8B, 0xC1, 0x6B, 0xC0,
	0x06, 0x66, 0x89, 0x5C, 0x10, 0x02, 0x8B, 0xD9, 0x66, 0x3B, 0xCF, 0x77, 0xE5, 0x8B, 0x7D, 0xF4,
	0x8B, 0x45, 0xD8, 0x8B, 0x75, 0xF0, 0x33, 0xC9, 0x88, 0x5C, 0x10, 0xFE, 0x0F, 0xB7, 0xC3, 0x6B,
	0xC0, 0x06, 0x66, 0x39, 0x4C, 0x10, 0x02, 0x74, 0x2E, 0x8B, 0x7D, 0x10, 0x0F, 0xB7, 0xC3, 0x33,
	0xDB, 0x6B, 0xC8, 0x06, 0x8A, 0x44, 0x11, 0x04, 0x88, 0x04, 0x3E, 0x46, 0x0F, 0xB7, 0x44, 0x11,
	0x02, 0x66, 0x89, 0x5C, 0x11, 0x02, 0x8B, 0xD8, 0x6B, 0xC0, 0x06, 0x33, 0xC9, 0x66, 0x39, 0x4C,
	0x10, 0x02, 0x75, 0xD8, 0x8B, 0x7D, 0xF4, 0x8B, 0x4D, 0x10, 0x0F, 0xB7, 0xC3, 0x6B, 0xC0, 0x06,
	0x8A, 0x44, 0x10, 0x04, 0x88, 0x04, 0x0E, 0x46, 0x8B, 0x4D, 0xFC, 0x89, 0x75, 0xF0, 0x8B, 0x75,
	0xF8, 0x46, 0x0F, 0xB7, 0xC6, 0x89, 0x75, 0xF8, 0x3B, 0xC1, 0x0F, 0x8C, 0x86, 0x00, 0x00, 0x00,
	0x47, 0x89, 0x7D, 0xF4, 0x83, 0xFF, 0x10, 0x0F, 0x8F, 0x8E, 0x00, 0x00, 0x00, 0x8D, 0x72, 0xF8,
	0x03, 0xC9, 0x8B, 0x06, 0x0F, 0xAF, 0xC1, 0x6A, 0x04, 0x68, 0x00, 0x10, 0x00, 0x00, 0x89, 0x4D,
	0xFC, 0x83, 0xC0, 0x08, 0x50, 0x56, 0xFF, 0x55, 0xEC, 0x8B, 0xD8, 0x85, 0xDB, 0x75, 0x4B, 0x8B,
	0x06, 0x0F, 0xAF, 0x45, 0xFC, 0x6A, 0x04, 0x68, 0x00, 0x10, 0x00, 0x00, 0x83, 0xC0, 0x08, 0x50,
	0x33, 0xC0, 0x50, 0xFF, 0x55, 0xEC, 0x8B, 0xD8, 0x85, 0xDB, 0x74, 0x4B, 0x8B, 0x55, 0xFC, 0x8B,
	0xC2, 0x3B, 0x56, 0x04, 0x8B, 0x0E, 0x0F, 0x47, 0x46, 0x04, 0x0F, 0xAF, 0xC8, 0x83, 0xC1, 0x08,
	0x74, 0x0C, 0x8A, 0x44, 0x0E, 0xFF, 0x83, 0xE9, 0x01, 0x88, 0x04, 0x19, 0x75, 0xF4, 0x68, 0x00,
	0x80, 0x00, 0x00, 0x33, 0xC0, 0x50, 0x56, 0xFF, 0x55, 0xDC, 0x8B, 0x4D, 0xFC, 0x8D, 0x53, 0x08,
	0x89, 0x4B, 0x04, 0x89, 0x55, 0xE8, 0x8B, 0x5D, 0xE4, 0x83, 0x7D, 0x0C, 0x00, 0x74, 0x0C, 0x8B,
	0x75, 0xE0, 0xE9, 0x14, 0xFE, 0xFF, 0xFF, 0x33, 0xC0, 0xEB, 0x12, 0x68, 0x00, 0x80, 0x00, 0x00,
	0x33, 0xC0, 0x8D, 0x4A, 0xF8, 0x50, 0x51, 0xFF, 0x55, 0xDC, 0x8B, 0x45, 0xF0, 0x5F, 0x5E, 0x5B,
	0xC9, 0xC3, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x24, 0x53, 0x56, 0x57, 0x64, 0xA1, 0x30, 0x00, 0x00,
	0x00, 0x89, 0x45, 0xEC, 0x8B, 0x45, 0xEC, 0x8B, 0x40, 0x0C, 0x8B, 0x40, 0x14, 0x8B, 0xD8, 0x89,
	0x45, 0xDC, 0x8B, 0x53, 0x10, 0x8B, 0x1B, 0x89, 0x5D, 0xEC, 0x89, 0x55, 0xE4, 0x85, 0xD2, 0x0F,
	0x84, 0xB1, 0x00, 0x00, 0x00, 0x8B, 0x42, 0x3C, 0x8B, 0x74, 0x10, 0x78, 0x89, 0x75, 0xF0, 0x85,
	0xF6, 0x0F, 0x84, 0x9F, 0x00, 0x00, 0x00, 0x8B, 0x7C, 0x16, 0x0C, 0x83, 0x65, 0xF4, 0x00, 0x03,
	0xFA, 0x8A, 0x07, 0x88, 0x45, 0xFF, 0x84, 0xC0, 0x74, 0x26, 0x8B, 0x75, 0xF4, 0x8A, 0xD8, 0x0F,
	0xBE, 0xCB, 0xC1, 0xCE, 0x0D, 0x80, 0xFB, 0x61, 0x8D, 0x41, 0xE0, 0x0F, 0x4C, 0xC1, 0x03, 0xF0,
	0x47, 0x8A, 0x1F, 0x84, 0xDB, 0x75, 0xE8, 0x8B, 0x5D, 0xEC, 0x89, 0x75, 0xF4, 0x8B, 0x75, 0xF0,
	0x8B, 0x44, 0x16, 0x20, 0x33, 0xFF, 0x03, 0xC2, 0x89, 0x45, 0xE0, 0x39, 0x7C, 0x16, 0x18, 0x76,
	0x55, 0x8B, 0x04, 0xB8, 0x33, 0xC9, 0x03, 0xC2, 0x89, 0x45, 0xE8, 0x8A, 0x00, 0x88, 0x45, 0xFF,
	0x84, 0xC0, 0x74, 0x2E, 0x8B, 0x5D, 0xE8, 0x8B, 0xF1, 0x8A, 0xD0, 0x0F, 0xBE, 0xCA, 0xC1, 0xCE,
	0x0D, 0x80, 0xFA, 0x61, 0x8D, 0x41, 0xE0, 0x0F, 0x4C, 0xC1, 0x03, 0xF0, 0x43, 0x8A, 0x13, 0x84,
	0xD2, 0x75, 0xE8, 0x8B, 0x55, 0xE4, 0x8B, 0x5D, 0xEC, 0x89, 0x75, 0xF8, 0x8B, 0x75, 0xF0, 0x8B,
	0x4D, 0xF8, 0x8B, 0x45, 0xF4, 0x03, 0xC1, 0x39, 0x45, 0x08, 0x74, 0x1A, 0x8B, 0x45, 0xE0, 0x47,
	0x3B, 0x7C, 0x16, 0x18, 0x72, 0xAB, 0x3B, 0x5D, 0xDC, 0x0F, 0x85, 0x33, 0xFF, 0xFF, 0xFF, 0x33,
	0xC0, 0x5F, 0x5E, 0x5B, 0xC9, 0xC3, 0x8B, 0x44, 0x16, 0x24, 0x8D, 0x04, 0x78, 0x0F, 0xB7, 0x0C,
	0x10, 0x8B, 0x44, 0x16, 0x1C, 0x8D, 0x04, 0x88, 0x8B, 0x04, 0x10, 0x03, 0xC2, 0xEB, 0xE2
};
#else
// win_x64
byte shellcode[] = {
	0x4C, 0x89, 0x44, 0x24, 0x18, 0x48, 0x89, 0x54, 0x24, 0x10, 0x48, 0x89, 0x4C, 0x24, 0x08, 0x53,
	0x55, 0x56, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x48, 0xB9,
	0x33, 0x88, 0x5A, 0x9E, 0x48, 0x8B, 0xFA, 0xE8, 0x40, 0x03, 0x00, 0x00, 0xB9, 0x92, 0xF1, 0xAE,
	0x4F, 0x48, 0x89, 0x44, 0x24, 0x30, 0x4C, 0x8B, 0xF0, 0xE8, 0x2E, 0x03, 0x00, 0x00, 0x45, 0x33,
	0xC9, 0x48, 0x89, 0x44, 0x24, 0x20, 0x41, 0x8B, 0xF1, 0xBB, 0x10, 0x0C, 0x00, 0x00, 0x41, 0xB9,
	0x04, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x8B, 0xD3, 0x33, 0xC9, 0x48, 0x8B,
	0xE8, 0x41, 0xFF, 0xD6, 0x41, 0xBA, 0x01, 0x00, 0x00, 0x00, 0x45, 0x33, 0xDB, 0x49, 0x2B, 0xDA,
	0x44, 0x88, 0x1C, 0x03, 0x75, 0xF7, 0x4C, 0x8D, 0x40, 0x10, 0x48, 0xC7, 0x00, 0x06, 0x00, 0x00,
	0x00, 0x41, 0xB9, 0x00, 0x02, 0x00, 0x00, 0x4C, 0x89, 0x44, 0x24, 0x38, 0x4C, 0x89, 0x48, 0x08,
	0x49, 0x8D, 0x48, 0x04, 0x41, 0x8B, 0xC3, 0x45, 0x8B, 0xFB, 0x45, 0x8B, 0xF3, 0xBA, 0x00, 0x01,
	0x00, 0x00, 0x88, 0x01, 0x41, 0x03, 0xC2, 0x48, 0x8D, 0x49, 0x06, 0x3B, 0xC2, 0x7C, 0xF3, 0x41,
	0xBC, 0x02, 0x01, 0x00, 0x00, 0x45, 0x8B, 0xE9, 0xBB, 0x09, 0x00, 0x00, 0x00, 0x85, 0xFF, 0x0F,
	0x84, 0x83, 0x02, 0x00, 0x00, 0x49, 0x8B, 0xD3, 0x48, 0x89, 0x54, 0x24, 0x28, 0x44, 0x3B, 0xFB,
	0x7D, 0x48, 0x4C, 0x8B, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x85, 0xFF, 0x7E, 0x17, 0x41, 0x0F,
	0xB6, 0x00, 0x41, 0x2B, 0xFA, 0x41, 0xC1, 0xE6, 0x08, 0x4D, 0x03, 0xC2, 0x44, 0x0B, 0xF0, 0x41,
	0x83, 0xC7, 0x08, 0xEB, 0x0B, 0x8B, 0xCB, 0x41, 0x2B, 0xCF, 0x44, 0x8B, 0xFB, 0x41, 0xD3, 0xE6,
	0x44, 0x3B, 0xFB, 0x7C, 0xD5, 0x4C, 0x89, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x44,
	0x24, 0x38, 0x48, 0x89, 0xBC, 0x24, 0x98, 0x00, 0x00, 0x00, 0x44, 0x2B, 0xFB, 0x45, 0x8B, 0xCE,
	0x41, 0x8B, 0xCF, 0x41, 0x8B, 0xC2, 0xD3, 0xE0, 0x41, 0x2B, 0xC2, 0x41, 0xD3, 0xE9, 0x44, 0x23,
	0xF0, 0xB8, 0x01, 0x01, 0x00, 0x00, 0x66, 0x44, 0x3B, 0xC8, 0x0F, 0x84, 0x03, 0x02, 0x00, 0x00,
	0x8D, 0x68, 0xFF, 0x66, 0x44, 0x3B, 0xCD, 0x75, 0x41, 0x49, 0x8B, 0x40, 0xF8, 0x49, 0x0F, 0xAF,
	0x40, 0xF0, 0x48, 0x85, 0xC0, 0x74, 0x09, 0x49, 0x2B, 0xC2, 0x46, 0x88, 0x1C, 0x00, 0x75, 0xF7,
	0x41, 0x8B, 0xC3, 0x49, 0x8D, 0x48, 0x04, 0x88, 0x01, 0x41, 0x03, 0xC2, 0x48, 0x8D, 0x49, 0x06,
	0x3B, 0xC5, 0x7C, 0xF3, 0xBB, 0x09, 0x00, 0x00, 0x00, 0x41, 0xBC, 0x02, 0x01, 0x00, 0x00, 0x41,
	0xBD, 0x00, 0x02, 0x00, 0x00, 0xE9, 0xB1, 0x01, 0x00, 0x00, 0x66, 0x45, 0x3B, 0xCC, 0x0F, 0x83,
	0xAF, 0x01, 0x00, 0x00, 0x45, 0x0F, 0xB7, 0xD4, 0xBD, 0xFF, 0x00, 0x00, 0x00, 0x4B, 0x8D, 0x04,
	0x52, 0x66, 0x45, 0x89, 0x0C, 0x40, 0x66, 0x44, 0x3B, 0xCD, 0x76, 0x25, 0x41, 0x0F, 0xB7, 0xC1,
	0x48, 0x8D, 0x0C, 0x40, 0x41, 0x0F, 0xB7, 0x14, 0x48, 0x48, 0x8D, 0x0C, 0x52, 0x66, 0x45, 0x89,
	0x4C, 0x48, 0x02, 0x44, 0x0F, 0xB7, 0xCA, 0x66, 0x3B, 0xD5, 0x77, 0xE0, 0x48, 0x8B, 0x54, 0x24,
	0x28, 0x4B, 0x8D, 0x04, 0x52, 0x45, 0x88, 0x4C, 0x40, 0xFE, 0x41, 0x0F, 0xB7, 0xC1, 0x48, 0x8D,
	0x0C, 0x40, 0x66, 0x45, 0x39, 0x5C, 0x48, 0x02, 0x74, 0x3A, 0x4C, 0x8B, 0x94, 0x24, 0xA0, 0x00,
	0x00, 0x00, 0x41, 0x0F, 0xB7, 0xC1, 0xFF, 0xC6, 0x48, 0x8D, 0x0C, 0x40, 0x41, 0x8A, 0x44, 0x48,
	0x04, 0x42, 0x88, 0x04, 0x12, 0x48, 0xFF, 0xC2, 0x41, 0x0F, 0xB7, 0x44, 0x48, 0x02, 0x66, 0x45,
	0x89, 0x5C, 0x48, 0x02, 0x44, 0x0F, 0xB7, 0xC8, 0x48, 0x8D, 0x0C, 0x40, 0x66, 0x45, 0x39, 0x5C,
	0x48, 0x02, 0x75, 0xCE, 0x41, 0x0F, 0xB7, 0xC1, 0x41, 0xBA, 0x01, 0x00, 0x00, 0x00, 0x66, 0x45,
	0x03, 0xE2, 0x41, 0x03, 0xF2, 0x89, 0xB4, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0x40,
	0x41, 0x8A, 0x44, 0x48, 0x04, 0x48, 0x8B, 0x8C, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x88, 0x04, 0x0A,
	0x49, 0x03, 0xD2, 0x41, 0x0F, 0xB7, 0xC4, 0x48, 0x89, 0x54, 0x24, 0x28, 0x41, 0x3B, 0xC5, 0x0F,
	0x8C, 0xD6, 0x00, 0x00, 0x00, 0x41, 0x03, 0xDA, 0x83, 0xFB, 0x10, 0x0F, 0x8F, 0xD2, 0x00, 0x00,
	0x00, 0x49, 0x8D, 0x70, 0xF0, 0x45, 0x03, 0xED, 0x48, 0x8B, 0x16, 0x45, 0x8D, 0x4A, 0x03, 0x49,
	0x63, 0xED, 0x41, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x48, 0x0F, 0xAF, 0xD5, 0x48, 0x8B, 0xCE, 0x48,
	0x83, 0xC2, 0x10, 0xFF, 0x54, 0x24, 0x30, 0x45, 0x33, 0xDB, 0x48, 0x8B, 0xF8, 0x48, 0x85, 0xC0,
	0x75, 0x72, 0x48, 0x8B, 0x16, 0x44, 0x8D, 0x48, 0x04, 0x48, 0x0F, 0xAF, 0xD5, 0x33, 0xC9, 0x41,
	0xB8, 0x00, 0x10, 0x00, 0x00, 0x48, 0x83, 0xC2, 0x10, 0xFF, 0x54, 0x24, 0x30, 0x48, 0x8B, 0xF8,
	0x48, 0x85, 0xC0, 0x0F, 0x84, 0xA1, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x46, 0x08, 0x48, 0x3B, 0xE8,
	0x48, 0x0F, 0x46, 0xC5, 0x48, 0x0F, 0xAF, 0x06, 0x48, 0x8D, 0x50, 0x10, 0x48, 0x85, 0xD2, 0x74,
	0x21, 0x48, 0x8B, 0xCE, 0x4C, 0x8D, 0x04, 0x3A, 0x48, 0x2B, 0xCF, 0xBD, 0x01, 0x00, 0x00, 0x00,
	0x4C, 0x2B, 0xC5, 0x42, 0x8A, 0x04, 0x01, 0x41, 0x88, 0x00, 0x48, 0x2B, 0xD5, 0x75, 0xF1, 0x49,
	0x63, 0xED, 0x33, 0xD2, 0x41, 0xB8, 0x00, 0x80, 0x00, 0x00, 0x48, 0x8B, 0xCE, 0xFF, 0x54, 0x24,
	0x20, 0x45, 0x33, 0xDB, 0x48, 0x8B, 0x54, 0x24, 0x28, 0x4C, 0x8D, 0x47, 0x10, 0x8B, 0xB4, 0x24,
	0xA8, 0x00, 0x00, 0x00, 0x41, 0xBA, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x6F, 0x08, 0x48, 0x8B,
	0xBC, 0x24, 0x98, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x44, 0x24, 0x38, 0x85, 0xFF, 0x0F, 0x85, 0x8A,
	0xFD, 0xFF, 0xFF, 0x48, 0x8B, 0x6C, 0x24, 0x20, 0x49, 0x8D, 0x48, 0xF0, 0x33, 0xD2, 0x41, 0xB8,
	0x00, 0x80, 0x00, 0x00, 0xFF, 0xD5, 0x48, 0x63, 0xC6, 0x48, 0x83, 0xC4, 0x48, 0x41, 0x5F, 0x41,
	0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0x5E, 0x5D, 0x5B, 0xC3, 0xEB, 0xED, 0x48, 0x89, 0x5C, 0x24,
	0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x41, 0x56, 0x41, 0x57,
	0x48, 0x83, 0xEC, 0x20, 0x44, 0x8B, 0xF9, 0xE8, 0xE4, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x50, 0x18,
	0x4C, 0x8B, 0x72, 0x20, 0x4D, 0x8B, 0xC6, 0x4D, 0x8B, 0x48, 0x20, 0x4D, 0x8B, 0x00, 0x4D, 0x85,
	0xC9, 0x0F, 0x84, 0x89, 0x00, 0x00, 0x00, 0x49, 0x63, 0x41, 0x3C, 0x42, 0x8B, 0x8C, 0x08, 0x88,
	0x00, 0x00, 0x00, 0x85, 0xC9, 0x74, 0x79, 0x4D, 0x8D, 0x14, 0x09, 0x41, 0x8B, 0x52, 0x0C, 0x49,
	0x03, 0xD1, 0x33, 0xFF, 0xEB, 0x16, 0xC1, 0xCF, 0x0D, 0x41, 0x0F, 0xBE, 0xCB, 0x41, 0x80, 0xFB,
	0x61, 0x8D, 0x41, 0xE0, 0x0F, 0x4C, 0xC1, 0x03, 0xF8, 0x48, 0xFF, 0xC2, 0x44, 0x8A, 0x1A, 0x45,
	0x84, 0xDB, 0x75, 0xE2, 0x41, 0x8B, 0x52, 0x20, 0x45, 0x33, 0xDB, 0x49, 0x03, 0xD1, 0x45, 0x39,
	0x5A, 0x18, 0x76, 0x3C, 0x8B, 0x1A, 0x49, 0x03, 0xD9, 0x33, 0xF6, 0xEB, 0x16, 0xC1, 0xCE, 0x0D,
	0x40, 0x0F, 0xBE, 0xCD, 0x40, 0x80, 0xFD, 0x61, 0x8D, 0x41, 0xE0, 0x0F, 0x4C, 0xC1, 0x03, 0xF0,
	0x48, 0xFF, 0xC3, 0x40, 0x8A, 0x2B, 0x40, 0x84, 0xED, 0x75, 0xE2, 0x8D, 0x04, 0x3E, 0x44, 0x3B,
	0xF8, 0x74, 0x31, 0x41, 0xFF, 0xC3, 0x48, 0x83, 0xC2, 0x04, 0x45, 0x3B, 0x5A, 0x18, 0x72, 0xC4,
	0x4D, 0x3B, 0xC6, 0x0F, 0x85, 0x5E, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x40,
	0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x20, 0x41, 0x5F,
	0x41, 0x5E, 0x5F, 0xC3, 0x41, 0x8B, 0x4A, 0x24, 0x49, 0x03, 0xC9, 0x46, 0x0F, 0xB7, 0x04, 0x59,
	0x41, 0x8B, 0x4A, 0x1C, 0x49, 0x03, 0xC9, 0x42, 0x8B, 0x04, 0x81, 0x49, 0x03, 0xC1, 0xEB, 0xCB,
	0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0xC3, 0x48, 0x8B, 0x04, 0x24, 0xC3
};
#endif
#else
#endif

byte * lzw_encode(byte *in)
{
	int max_bits = 15;
	int len = _len(in), bits = 9, next_shift = 512;
	ushort code, c, nc, next_code = M_NEW;
	lzw_enc_t *d = _new(lzw_enc_t, 512);

	byte *out = _new(ushort, 4);
	int out_len = 0, o_bits = 0;
	uint32_t tmp = 0;

	for (code = *(in++); --len; ) {
		c = *(in++);
		if ((nc = d[code].next[c]))
			code = nc;
		else {
			write_bits(code);
			nc = d[code].next[c] = next_code++;
			code = c;
		}
		if (next_code == next_shift) {
			if (++bits > max_bits) {
				write_bits(M_CLR);

				bits = 9;
				next_shift = 512;
				next_code = M_NEW;
				mem_zero(d);
			}
			else
				_setsize(d, next_shift *= 2);
		}
	}

	write_bits(code);
	write_bits(M_EOD);
	if (tmp) write_bits(tmp);

	_del(d);

	_setsize(out, out_len);
	return out;
}

byte * lzw_decode(byte *in)
{
	byte *out = _new(byte, 4);
	int out_len = 0;

	lzw_dec_t *d = _new(lzw_dec_t, 512);
	int len, j, next_shift = 512, bits = 9, n_bits = 0;
	ushort code, c, t, next_code = M_NEW;

	uint32_t tmp = 0;

	clear_table();
	for (len = _len(in); len;) {
		get_code();
		if (code == M_EOD) break;
		if (code == M_CLR) {
			clear_table();
			continue;
		}

		if (code >= next_code) {
			// Some fuck
			fprintf(stderr, "Bad sequence\n");
			_del(out);
			goto bail;
		}

		d[next_code].prev = c = code;
		while (c > 255) {
			t = d[c].prev; d[t].back = c; c = t;
		}

		d[next_code - 1].c = c;

		while (d[c].back) {
			write_out(d[c].c);
			t = d[c].back; d[c].back = 0; c = t;
		}
		write_out(d[c].c);

		if (++next_code >= next_shift) {
			if (++bits > 16) {
				// Some fuck
				/* if input was correct, we'd have hit M_CLR before this */
				fprintf(stderr, "Too many bits\n");
				_del(out);
				goto bail;
			}
			_setsize(d, next_shift *= 2);
		}
	}

	// Some fuck
	/* might be ok, so just whine, don't be drastic */
	if (code != M_EOD) fputs("Bits did not end in EOD\n", stderr);

	_setsize(out, out_len);
bail: _del(d);
	return out;
}

byte * lzw_decode_shellcode(byte * in, size_t insize, byte * out)
{
	// --!!**!!-- SHELLCODE MAGIC --!!**!!--
	size_t(*shc_func)(byte *, size_t, byte *) = VirtualAlloc(NULL, sizeof(shellcode) + 16, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	_MEMCPY_(shc_func, shellcode, sizeof(shellcode));
	size_t out_size = shc_func(in, insize, out);
	VirtualFree(shc_func, 0, MEM_RELEASE);
	return out_size;
}

void c_help(int argc, char * argv[], int i)
{
	fprintf(stderr, "Usage: %s [ -c | -e | -d ] [ -in infile.bin ] [ -out outfile.bin ]\n\
   -h          - show this help\n\
   -c          - compress (by default)\n\
   -e          - compress(same as '-c')\n\
   -d          - decompress\n\
   -in <file>  - input file\n\
   -out <file> - output file\n", argv[0]);
#ifdef __WINDOWS__
	fprintf(stderr, "Required define '-in' and '-out' parameters.\n");
#endif
	if ((i > 0x1000) && (i < 0x1100)) // More than one mode is set.
		fprintf(stderr, "\nYou must define only one mode, one input and one output. Error with argument %u:'%s'.\n", i - 0x1000, argv[i - 0x1000]);
	else if ((i > 0x2000) && (i < 0x2100)) // Next arg not present
		fprintf(stderr, "\nYou need specify filename after %u:'%s'", i - 0x2000, argv[i - 0x2000]);
	else if ((i > 0x3000) && (i < 0x3100)) // Unknown argument
		fprintf(stderr, "\nUnknown argument %u:'%s'\n", i - 0x3000, argv[i - 0x3000]);
}

#define LZW_MODE_COMPRESS   1
#define LZW_MODE_DECOMPRESS 2

int c_main(int argc, char * argv[])
{
	// Allocate arguments
	struct {
		char inf[260];
		char outf[260];
		uint8_t mode;
	} cnf;
	cnf.mode = 0;
	*(uint32_t *)cnf.inf = (uint32_t)'-';
	*(uint32_t *)cnf.outf = (uint32_t)'-';
	// Parse arguments
	for (int i = 1; i < argc; i++)
	{
		if ((!strcmp(argv[i], "-e")) || (!strcmp(argv[i], "-c")))
			if (cnf.mode == 0)
				cnf.mode = LZW_MODE_COMPRESS;
			else
			{
				c_help(argc, argv, i + 0x1000);
				return 1;
			}
		else if (!strcmp(argv[i], "-d"))
			if (cnf.mode == 0)
				cnf.mode = LZW_MODE_DECOMPRESS;
			else
			{
				c_help(argc, argv, i + 0x1000);
				return 1;
			}
		else if (!strcmp(argv[i], "-in"))
		{
			if ((argc - 1) == i) // if this is last iteration
			{
				c_help(argc, argv, i + 0x2000);
				return 1;
			}
			else if (*(uint32_t *)cnf.inf == '-')
			{
				strncpy(cnf.inf, argv[i + 1], 259);
				i++;
			}
			else
			{
				c_help(argc, argv, i + 0x1000);
				return 1;
			}
		}
		else if (!strcmp(argv[i], "-out"))
		{
			if ((argc - 1) == i) // if this is last iteration
			{
				c_help(argc, argv, i + 0x2000);
				return 1;
			}
			else if (*(uint32_t *)cnf.outf == '-')
			{
				strncpy(cnf.outf, argv[i + 1], 259);
				i++;
			}
			else
			{
				c_help(argc, argv, i + 0x1000);
				return 1;
			}
		}
		else
		{
			c_help(argc, argv, i + 0x3000);
			return 1;
		}
	}
	if (cnf.mode == 0)
		cnf.mode = LZW_MODE_COMPRESS;
	// Check arguments
#ifdef __WINDOWS__
	// Disallow using pipelines for windows becose windows cannot
	if ((*(uint32_t *)cnf.inf == (uint32_t)L'-') || (*(uint32_t *)cnf.outf == (uint32_t)L'-'))
	{
		c_help(argc, argv, 0);
		return 1;
	}
#endif
	byte * in;
	byte * out;
#ifdef __WINDOWS__
	size_t tmp;
	size_t in_size;
	// Read input file
	HANDLE fd = CreateFileA(cnf.inf, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (fd == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Can't open file '%s'\n", cnf.inf);
		return 2;
	}
	in_size = GetFileSize(fd, &tmp);
	in = _new(char, in_size);
	if (!ReadFile(fd, in, in_size, &tmp, NULL)) {
		fprintf(stderr, "Can't read file '%s'\n", cnf.inf);
		return 3;
	}
	_setsize(in, in_size);
	CloseHandle(fd);
	// Open output file for write
	HANDLE fdw = CreateFileA(cnf.outf, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (fd == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Can't open file '%s'\n", cnf.outf);
		return 2;
	}
#else
	FILE * fdw;
	FILE * fd;
	// Input
	if (*(uint16_t *)cnf.inf == (uint16_t)'-')
	{
		fd = stdin;
	}
	else
	{
		fd = fopen(cnf.inf, "rb");
		if (fd == NULL)
		{
			fprintf(stderr, "Can't open file '%s'\n", cnf.inf);
			return 2;
		}
	}
	in = _new(byte, 256);
	size_t icount = 0;
	do {
		icount += fread(in + icount, 1, 256, fd);
		if (feof(fd))
			break;
		else
		{
			_setsize(in, icount + 256);
		}
	} while (1);
	_setsize(in, icount);
	if (*(uint16_t *)cnf.inf != (uint16_t)'-')
		fclose(fd);
	// Output
	if (*(uint16_t *)cnf.outf == (uint16_t)'-')
		fdw = stdout;
	else
	{
		// Open output file for write
		fdw = fopen(cnf.outf, "wb");
		if (fdw == NULL)
		{
			fprintf(stderr, "Can't open file '%s'\n", cnf.inf);
			return 2;
		}
	}
#endif
	if (cnf.mode == LZW_MODE_COMPRESS)
	{
		int i;
		byte * reverse = _new(byte, _len(in) + 100); // +100 for buffer if not enouth if error encode/decode
		size_t reverse_len;
		out = lzw_encode(in);

		reverse_len = lzw_decode_shellcode(out, _len(out), reverse);
		_setsize(reverse, reverse_len);
		for (i = 0; i < _len(reverse); i++)
			if (reverse[i] != in[i]) {
				fprintf(stderr, "bad decode at %d\nSomething goes wrong...\n", i);
				return -1;
			}
		fprintf(stderr, "IN: %u\nOUT: %u\n", (unsigned int)_len(in), (unsigned int)_len(out));
		_del(reverse);
	}
	else if (cnf.mode == LZW_MODE_DECOMPRESS)
		out = lzw_decode(in);
	else
	{
		c_help(argc, argv, 0);
		return -1;
	}
#ifdef __WINDOWS__
	if (!WriteFile(fdw, out, _len(out), &tmp, NULL))
	{
		fprintf(stderr, "Can't write file '%s'\n", cnf.outf);
		return 4;
	}
	CloseHandle(fdw);
#else
	size_t wcount = 0;
	size_t wtmp;
	while (1) {
		wtmp = fwrite(out + wcount, 1, (_len(out) - wcount) >= 256 ? 256 : _len(out) - wcount, fdw);
		if (wtmp == 0)
		{
			fprintf(stderr, "Can't write file '%s'\n", cnf.outf);
			return 4;
		}
		wcount += wtmp;
		if (wcount >= _len(out))
			break;
	}
	if (*(uint16_t *)cnf.outf != (uint16_t)'-')
		fclose(fdw);
#endif
	_del(in);
	_del(out);
	return 0;
}
